# 用例 #221：AI 代码重构顾问

**角色**：开发工程师 / 高级工程师 / 技术负责人 | **行业**：科技、SaaS、金融科技、企业软件 | **任务**：遗留代码现代化、重构策略、代码质量提升

---
## 详细介绍

**痛点：没人想碰、但人人都不得不碰的遗留代码**

遗留代码是软件工程的"引力"——无处不在、持续存在、抵抗成本越来越高。问题不仅仅在于代码老旧，更在于它承载着多年来已不复存在的上下文假设：离职的开发者、变更的需求、当年合理但如今成为障碍的架构决策。一个运行 5 年以上的 Rails 或 Spring Boot 企业应用，会有一些模块让高级工程师在打开文件前也会犹豫——不是因为他们能力不够，而是误解一个隐性依赖的代价，可能是凌晨两点的生产故障。

重构困境真实且普遍。团队知道应该重构，但问题始终是：怎么做？应该抽出一个服务？拆分一个类？引入一个抽象层？错误的重构往往比不重构更糟——它只是移动了复杂度，而不是消除它；给一个至少还稳定的模块增加了变更扰动；消耗数周努力却毫无实质改善。没有系统性的、感知模式的方法，重构就成了"谁说话声音最大谁说了算"的赌注。

更大的风险是，"以后再重构"变成"永远不重构"。随着业务压力增大、代码库持续扩张，有意义的重构窗口逐渐关闭。2022 年只需两周的重构，到现在可能需要两个月的迁移，到 2026 年就变成了涉及全系统的重写讨论。每拖延一个季度，成本就上升一级，可能性就下降一级。

**COCO 如何解决**

COCO 的 AI 代码重构顾问分析遗留代码模式，生成具体、可执行的重构策略，并附带工时估算和风险评估——给工程师一张路线图，而不是一张白纸。

1. **遗留模式识别与分类**：COCO 识别具体的反模式，并按重构类型进行分类。
   - 检测结构性反模式：God Object（超过 500 行、20 个以上方法的类）、Feature Envy（方法使用其他类数据多于自身类数据）、Shotgun Surgery（单一改动需要在多处修改）、Data Clumps
   - 识别架构层面的代码异味：大泥球模块、包之间的不当亲密耦合、层级违规
   - 按标准重构策略对每个发现分类（提取方法、用多态替换条件、引入参数对象等）
   - 对每个模式的严重性进行 1–5 分评级并附理由

2. **具体重构策略生成**：COCO 不提供泛泛建议，而是为每个识别出的问题提供具体的转换计划。
   - 对于提取方法候选：识别要提取的精确代码块、建议方法名称、确定提取方法应放置的位置
   - 对于类分解：提出具体的类边界、职责分配和接口契约
   - 对于条件复杂性：建议策略模式、状态机或分发表，并附代码草图
   - 为非显而易见的重构提供前后对比的伪代码示意

3. **工时与风险估算**：每个重构建议都附带实际的成本收益分析。
   - 工时估算：小（< 4 小时）、中（1–3 天）、大（1–2 周）或史诗级（需要分阶段执行）
   - 风险评级：基于受影响代码的测试覆盖率、调用方/依赖方数量，以及变更是否跨越模块边界
   - 区分"安全"重构（测试完善、隔离性好、收益明确）与需要先补充测试覆盖的重构
   - 标记过渡期间需要功能开关保护或向后兼容桥接的重构

4. **排序与依赖感知规划**：重构操作的顺序至关重要——某些变换必须先于其他变换进行。
   - 生成重构操作的依赖图（"必须先分解 God Object A，才能提取服务 B"）
   - 基于风险调整后的价值推荐排序：先做低风险、高价值项，建立信心和动力
   - 识别能解锁多个下游改进的"基础性"重构
   - 生成与并行功能开发兼容的分阶段计划——无需"停工"的重构月

5. **重构安全性的测试覆盖缺口分析**：没有测试的重构，不过是换了个名字的重写。
   - 分析重构目标代码的现有测试覆盖率
   - 识别特征化测试机会：在重构开始前需要捕获哪些行为
   - 建议最小化的测试补充，以在不需要先完成完整测试套件的前提下提供重构安全保障
   - 推荐适合遗留代码的审批测试工具（如快照测试、黄金主模板测试）

6. **语言与框架专项指导**：重构模式因语言而异。COCO 提供适配你具体技术栈的建议。
   - Python：dataclass 迁移、类型注解补充、async 迁移模式、Django ORM 优化模式
   - Java：Spring 现代化（XML → 注解 → 函数式）、Optional 迁移、Records 采用、模块系统迁移
   - TypeScript：strict 模式采用路径、接口隔离、Utility Type 重构
   - Node.js：callback → Promise → async/await 迁移、ESM 迁移、Express → 框架化模式

**量化结果**

- **重构成功率**：使用 COCO 策略建议的团队，"重构后反而变得更糟"的事故比无指导方法减少 70%
- **工时估算准确性**：80% 的案例中，重构工时估算误差在 ±25% 以内，而非正式估算的误差可达 ±200%
- **速率恢复**：按照 COCO 建议进行重构后，高债务模块在 2 个季度内速率提升 15–35%
- **代码复杂度降低**：被针对的模块在采纳 COCO 建议后，平均圈复杂度降低 40–60%
- **测试覆盖改善**：重构前生成特征化测试，使重构引发的生产事故减少 65%
- **规划时间**：重构迭代规划从 2 天的设计会议缩短至 4 小时的范围界定会议

**谁会受益**

- **高级 / 首席工程师**：获得结构化框架，将模式识别转化为有可辩护理由的可执行计划
- **技术负责人**：可将大型重构史诗拆解为安全排序的、迭代粒度的工作项分配给团队
- **初中级工程师**：通过具体的代码示例学习重构模式，而非抽象理论
- **工程经理**：获得可规划、可跟踪的工时和风险估算，使重构工作能与功能开发并行管理

---

## 实用提示词

**提示词 1：单模块深度重构分析**
```
我需要对代码库中的一个特定模块制定重构计划。

模块背景：
- 语言：[Python 3.9 / Java 17 / TypeScript 5 / 等]
- 框架：[Django / Spring Boot / NestJS / 等]
- 文件/类名称：[如 OrderProcessingService.java]
- 大致规模：[N 行，N 个方法/函数]
- 年龄：[上次大规模重构的时间]
- 测试覆盖率：[% 覆盖率，或"极少"、"无"]
- 已知问题：[描述工程师遇到的问题：慢、脆弱、难以扩展等]

[在下方粘贴代码，或描述你观察到的主要模式]

请：
1. 识别所有主要反模式，并附具体的行/函数引用
2. 按标准重构模式名称分类（Fowler 目录或同等参考）
3. 为前 3 个问题提供具体重构策略，包括前后结构对比
4. 估算每项重构的工时和风险
5. 推荐安全的执行顺序
6. 识别在开始前应编写哪些特征化测试
```

**提示词 2：遗留代码库 6 个月重构路线图**
```
我接手了一个遗留 [语言] 代码库，需要制定 6 个月的重构路线图。

代码库背景：
- 语言/框架：[如 Ruby on Rails 5.2，部分模块仍有 Python 2.7]
- 年龄：[运行年限，已知的上次大规模重构时间]
- 规模：[代码行数，文件/类数量]
- 当前测试覆盖率：[总体 %，各层级如已知]
- 团队：[N] 名工程师负责执行
- 业务约束：[功能开发必须并行进行]
- 不可更改的约定：[任何禁止触碰的模块，或任何截止日期]

最差的区域（来自我的初步探索）：
1. [描述区域 1：功能、痛点]
2. [描述区域 2]
3. [描述区域 3]

请输出：
1. 每个问题区域的模式分析与具体重构策略
2. 按风险排序的重构优先级列表
3. 安全排序工作的分阶段 6 个月路线图
4. 第一个迭代可执行的"快速见效"项目，用于建立动力
5. 我应追踪的进展指标（复杂度趋势、覆盖率、事故率）
6. 每个区域的决策框架："重构" vs. "重写" vs. "封装隔离"
```

**提示词 3：类/函数分解计划**
```
我有一个 [God Class / 单体函数 / 超大模块] 需要被分解。

当前状态：
- 名称：[类名或函数名]
- 语言：[语言]
- 规模：[N 行，N 个方法（如果是类）]
- 功能：[描述职责——具体说明它当前处理的多重关注点]
- 当前调用方/消费方：[数量、哪些模块、是外部 API 还是内部调用]
- 测试覆盖率：[% 或描述]

[粘贴代码或代表性片段]

我需要：
1. 职责分析——这个类/函数当前处理了哪些不同的关注点？
2. 建议的分解方案：它应该变成哪些类/函数？
3. 每个新组件的接口契约
4. 安全的增量迁移路径（我不能做大爆炸式替换）
5. 如适用，推荐绞杀者模式或其他迁移模式
6. 迁移期间如何为现有调用方保持向后兼容
```

**提示词 4：条件复杂度重构**
```
我有深度嵌套的条件逻辑，已变得难以维护。

背景：
- 语言：[语言]
- 代码处理的是：[描述这段逻辑——如"基于国家、支付方式和金额的支付路由"]
- 当前结构：[描述：嵌套 if/else、switch 语句、策略标志等]
- 条件/分支数量：[N]
- 新增分支的频率：[频率]
- 当前测试覆盖率：[%]

[在下方粘贴代码]

请推荐：
1. 最适合的重构模式：Strategy、State Machine、Command、Dispatch Table、Rule Engine 或其他
2. 在 [语言] 中的具体实现计划，附代码结构（不是伪代码——提供实际的类/函数名）
3. 如何在不破坏现有行为的前提下增量迁移
4. 如何让未来工程师能便捷地添加新分支
5. 重构后版本的测试方案
```
