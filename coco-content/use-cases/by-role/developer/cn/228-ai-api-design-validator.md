# Use Case #228: AI API Design Validator

**Role**: Developer / API Engineer / Tech Lead / Platform Engineer | **Industry**: Technology, SaaS, Fintech, Developer Platforms | **Task**: API Design Review, Contract Validation, API Governance

---
## 详细介绍

**痛点：第一天正常工作、第一百天让团队崩溃的 API**

API 是契约。与可以自由重构的内部代码不同，API 有依赖其稳定性的外部消费者——无论这些消费者是第三方开发者、移动客户端，还是其他内部团队。设计糟糕的 API 在有消费者之后几乎无法修复：你无法重命名已有数千个客户端应用解析的字段，无法更改合作伙伴系统已经处理的状态码，无法重构移动应用已经发版依赖的响应结构。每一个设计错误，要么是永久的，要么需要一次代价高昂的迁移——拉紧消费者关系，并要求大量协调工作。

具体的失败模式是一致的：不统一的命名约定（某些接口用 snake_case，其他用 camelCase），迫使客户端开发者编写特殊处理；非惯用的 HTTP 用法（用 POST 做读操作、错误时返回 200、状态码使用不一致），破坏标准库行为；过于"话痨"的 API，完成一个用户动作需要 6 次请求，每次都有自己的延迟；为 API 作者方便而结构化的嵌套资源，而非为客户端效率设计；列表接口缺少分页，在开发中正常返回 5 万条记录，在生产中造成超时；客户端开发者无法据此行动的不透明错误消息。这些不是失误——它们是在没有对照系统标准审查 API 设计时自然出现的模式。

GraphQL 和 gRPC 引入了它们各自的失败模式：GraphQL Schema 结构中内嵌的 N+1 查询风险、违反 CQRS 原则的 Mutation、破坏序列化兼容性的 Protobuf 字段编号冲突、不考虑流式背压的 gRPC 服务定义。没有理解每种 API 范式特定惯用法的工具，设计评审就会变得不一致，依赖于审查者对每种协议的熟悉程度。

**COCO 如何解决**

COCO 的 AI API 设计验证器根据协议特定最佳实践检查 API 契约，识别建议变更中的向后兼容风险，并生成消费者迁移指南——确保 API 从一开始就为长期稳定性和开发者体验而设计。

1. **REST API 最佳实践验证**：COCO 对每个 API 设计应用全面的 REST 惯用法检查清单。
   - 验证资源命名：基于名词的接口、复数集合、一致的大小写、路径中无动词（适合 RPC 风格接口的情况除外）
   - 检查 HTTP 方法语义：GET/POST/PUT/PATCH/DELETE 的正确使用、幂等性期望满足、安全方法不产生副作用
   - 审查状态码使用：正确的 2xx/4xx/5xx 区分、一致的错误响应格式（RFC 7807 Problem Details 或同等方案）、无携带错误体的 200 OK
   - 验证分页设计：游标分页 vs. 偏移分页的适宜性、响应信封一致性、导航用的 Link Headers
   - 检查过滤、排序和字段选择设计，确保查询 API 的完整性和一致性
   - 审查认证和授权模式：Header 约定、Scope 定义、Token 格式一致性

2. **GraphQL Schema 验证**：GraphQL 有其独特的设计陷阱，不同于 REST。
   - 识别 Schema 设计中的 N+1 查询风险：没有 DataLoader 模式就会导致 O(n) Resolver 调用的关联关系
   - 审查 Mutation 设计：Input 类型一致性、Mutation 响应结构（受影响对象 + 错误）、CQRS 合规
   - 检查 Subscription 设计：事件粒度、Subscription 中的授权、扩展性考虑
   - 验证命名约定：类型名、字段名、枚举值遵循 GraphQL 社区约定
   - 审查错误处理：用户侧错误 vs. 系统错误、错误扩展、一致的错误码分类

3. **gRPC / Protobuf 设计审查**：线协议决策一旦有消费者就无法更改。
   - 验证字段编号策略：保留字段编号的正确使用、未来添加时冲突的风险
   - 审查服务方法命名：惯用的 RPC 命名、每个方法的流式 vs. 一元的适宜性
   - 检查建议 Schema 变更的向后兼容性：添加必填字段、更改字段类型、删除字段
   - 评估服务分解：这个服务定义的范围是否合适？太粗？太细？
   - 审查错误状态码使用是否符合 gRPC 状态码语义

4. **向后兼容性分析**：对有现有消费者的 API，这是最关键的审查。
   - 分析建议的 API 变更与当前 API 版本，识别破坏性 vs. 非破坏性变更
   - 分类每项变更：向后兼容的新增（安全）、非破坏性行为变更（附文档说明安全）、破坏性变更（需要迁移策略）
   - 识别"静默破坏性变更"——不改变 Schema 但改变语义的变更：变更的验证规则、变更的排序行为、变更的分页默认值
   - 推荐版本控制策略：URL 版本化（/v1/、/v2/）、Header 版本化（Accept: application/vnd.api+json;version=2）或 GraphQL/gRPC 的演进式方法

5. **消费者迁移指南生成**：当破坏性变更不可避免时，减少迁移负担。
   - 为每项破坏性变更生成带明确"变更前"和"变更后"的变更日志
   - 在常见客户端语言（Python、JavaScript/TypeScript、Java、Go）中生成代码迁移示例，展示如何更新客户端代码
   - 创建双版本支持的弃用时间线：旧 API 版本与新版本并行维护多长时间
   - 起草面向 API 消费者的迁移沟通模板

6. **OpenAPI / AsyncAPI 规范验证**：规范优先的 API 开发需要规范的正确性。
   - 验证 OpenAPI 3.0/3.1 和 Swagger 2.0 规范的完整性和正确性
   - 检查所有请求/响应 Schema 是否完整规定（无无 Schema 的接口）
   - 识别缺失的示例、缺失的错误响应定义和不完整的参数文档
   - 验证安全 Scheme 定义是否完整且一致应用
   - Lint 事件驱动 API 设计（Kafka、WebSocket、AMQP）的 AsyncAPI 规范

**可量化的结果**

- **发布前捕获设计问题**：使用 API 设计审查的团队在 API 有消费者前捕获 75% 的设计问题，而非结构化流程只有 25%
- **破坏性变更事故**：系统性向后兼容性分析使无意的破坏性变更到达消费者的情况减少 80%
- **开发者体验评分**：经 COCO 审查的 API 从 API 消费者那里获得高 40% 的开发者满意度评分
- **迁移工作量**：COCO 生成的迁移指南比单独的 API 变更日志减少消费者迁移工作量 50%
- **API 审查时间**：全面设计审查时间从 3 小时的手动会议缩短至 45 分钟的 COCO 辅助会话
- **规范完整性**：API 规范完整性从平均 55% 提升至 90% 以上（有 COCO 验证）

**受益角色**

- **API 工程师 / 后端开发者**：获得系统性验证，在设计问题成为永久错误前捕获它们
- **平台团队**：建立跨团队扩展的一致 API 治理标准，同时不制造审查瓶颈
- **开发者关系 / API 消费者团队**：收到设计更好、更一致、文档更完整的 API
- **技术负责人**：以编程方式强制执行 API 设计标准，而非依赖个别审查者的知识

---

## 实用提示词

**提示词 1：REST API 设计审查**
```
请对以下 REST API 设计的正确性、一致性和最佳实践进行审查。

API 背景：
- 用途：[这个 API 的功能，谁在使用：内部/外部/第三方]
- 当前消费者：[尚无 / 移动应用 / 第三方合作伙伴 / 内部服务]
- 认证方式：[JWT / OAuth2 / API Key / 其他]
- 版本控制方式：[URL / Header / 无]

[粘贴 API 规范（OpenAPI YAML/JSON，或带请求/响应示例的接口列表）]

或描述关键接口：
- GET /[路径]：[描述，查询参数，响应结构]
- POST /[路径]：[描述，请求体，响应结构]
- PUT/PATCH /[路径]：[描述]
- DELETE /[路径]：[描述]

请审查：
1. 资源命名和 URL 结构一致性
2. HTTP 方法使用和状态码正确性
3. 请求/响应 Schema 设计和命名约定
4. 错误响应格式和完整性
5. 分页、过滤和排序设计
6. 认证和授权模式
7. API 设计隐含但缺失的接口（CRUD 完整性等）
8. 生成按严重性排序的问题列表，每个问题附具体修复建议
```

**提示词 2：API 变更的向后兼容性分析**
```
我正在提议对一个有消费者的现有 API 进行变更。我需要向后兼容性分析。

当前 API（v[N]）：
[粘贴或描述当前 API 规范]

建议的变更：
[粘贴或描述 API 的建议变更]
- [变更 1：如"为统一性将字段 'user_id' 重命名为 'userId'"]
- [变更 2：如"在 POST /orders 中添加必填字段 'country_code'"]
- [变更 3：如"将分页从偏移式改为游标式"]
- [变更 4：如"删除已弃用接口 GET /legacy/users"]

消费者背景：
- 已知消费者数量：[N]
- 消费者类型：[移动应用 / Web 应用 / 第三方合作伙伴 / 内部服务]
- 消费者更新能力：[可立即推送更新 / 移动端发版周期长 / 有自己时间线的第三方]

请：
1. 将每个建议变更分类为：破坏性 / 非破坏性 / 静默破坏性变更
2. 对每个破坏性变更，提出迁移策略
3. 推荐这组变更的版本控制方式
4. 建议旧行为的弃用时间线
5. 为消费者生成迁移指南，附 [JavaScript/Python/Java] 的变更前后代码示例
6. 为每个变更起草 API 变更日志条目
```

**提示词 3：GraphQL Schema 设计审查**
```
请对我们的 GraphQL Schema 设计进行最佳实践、N+1 风险和设计一致性审查。

Schema 背景：
- 后端：[Node.js/Apollo / Python/Strawberry / Java/DGS / Go/gqlgen / 其他]
- 消费者：[Web 应用 / 移动端 / 第三方]
- 认证：[如何在 Resolver 中处理认证]
- DataLoader 使用情况：[是 / 否 / 部分]

[粘贴 GraphQL Schema（SDL 格式）]

我关注的关键 Query/Mutation：
- [Query/Mutation 名称]：[描述关注点]
- [Query/Mutation 名称]：[描述关注点]

请审查：
1. Schema 结构和类型命名约定
2. N+1 Resolver 风险——识别所有在没有 DataLoader 的情况下会导致级联查询的关联字段
3. Mutation 设计——Input 类型、响应类型、错误处理方式
4. 查询深度和复杂度——是否有可能 DoS 服务器的无界查询？
5. 授权模式——授权在 Schema 的哪里、如何强制执行？
6. Schema 设计隐含但未包含的缺失类型或字段
7. 分页设计——基于 Connection 的分页是否正确实现？
8. 为识别出的 N+1 风险推荐具体的 DataLoader 模式
```
