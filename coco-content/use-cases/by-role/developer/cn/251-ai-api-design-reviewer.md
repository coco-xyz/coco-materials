# 使用案例 #251：AI API 设计审查器

**角色**：开发者 | **行业**：SaaS、企业软件、平台工程、开发者工具 | **任务**：代码审查、API 设计、架构

---
## 详细介绍

**痛点：糟糕的 API 设计是每一个集成方永久缴纳的税**

API 设计决策是软件团队所做出的最重要、也最难以撤销的选择之一。一个命名不当的端点、不一致的错误响应格式、缺失的分页机制、一个名为 `status` 且接受 11 种不同字符串值却没有枚举定义的字段——这些决策一旦发布，被 3 个内部团队集成，然后被 7 个外部客户集成，就几乎无法再改动。之后的任何变更都需要版本控制、迁移期、弃用通知，以及与每个依赖系统的协调。糟糕的 API 设计决策的成本随着每一个新集成的建立而叠加。

API 设计这门学科在工程流程中频繁被视为次要事项。在标准的功能开发流程中，工程师负责构建一项功能，设计支持该功能的 API，编写实现，接受主要聚焦于实现的代码审查，然后发布。API 设计审查——即使真的进行了——也是由同一工程师或同事通过查看代码而非 API 契约来完成的。没有人停下来系统性地问：这个资源名称是否符合我们现有的命名规范？这个端点是否以会让集成方困惑的方式违反了 REST 语义？当请求方传入无效的参数组合时会发生什么——那个错误响应真的有用吗？

后果是可预见的。Stripe 是以 API 设计著称的公司之一，它已经公开分享了实现 API 一致性所需的内部纪律——专门的 API 审查委员会、长达数十页的设计指南，以及将 API 设计视为公开承诺的文化。大多数团队没有这些基础设施，技术债务于是不断积累。一家中型 SaaS 公司的内部审计发现，在其 140 个 API 端点中，错误响应有 31 种截然不同的模式：有些返回 `{"error": "not found"}`，有些返回 `{"message": "Resource not found", "code": 404}`，还有些返回 `{"errors": [{"type": "NOT_FOUND", "detail": "..."}]}`。每个集成方都必须处理所有 31 种模式，否则就要接受静默失败。

**COCO 如何解决这个问题**

COCO 的 AI API 设计审查器对 API 定义进行系统性设计审查，在 API 发布前捕获一致性违规、安全问题、可用性问题和文档缺口。

1. **REST 和 HTTP 语义审查**：验证对 HTTP 约定的正确使用。
   - 检查 HTTP 动词的正确使用：GET 用于读取（幂等，无副作用）、POST 用于创建、PUT/PATCH 用于更新、DELETE 用于删除
   - 验证状态码的使用：创建返回 201，空成功返回 204，不同验证失败类型使用 400 与 422，区分 401 与 403
   - 识别资源命名规范的违反：资源名称中的动词、不一致的复数形式、层次资源的非层次化 URL 结构
   - 标记 HATEOAS 机会并评估 API 的导航模型是否连贯

2. **一致性分析**：评估 API 接口整体的内部一致性。
   - 识别不一致的命名规范：字段名中的驼峰命名与蛇形命名混用、中英文字段名混用、字段名缩写与全称混用
   - 检测端点间不一致的错误响应格式，并提议统一的错误模式
   - 标记不一致的分页：部分端点使用游标分页，其他使用偏移分页，且没有文档化的理由
   - 识别不一致的认证头部使用、同一 API 接口内不一致的版本控制方式

3. **安全设计审查**：识别 API 设计阶段引入的安全漏洞。
   - 检测过度数据暴露：当只需要部分字段时，端点返回完整对象图
   - 识别缺失或不充分的限流规范
   - 标记应使用不透明标识符的直接对象引用模式
   - 识别应在 API 设计层面指定的授权逻辑
   - 评估输入验证规范：哪些字段有验证规则，哪些无界，注入风险可能在哪里

4. **可用性和开发者体验审查**：从集成方的角度评估 API。
   - 识别需要多个顺序 API 调用才能完成的操作，而一个端点本可以更好地服务
   - 标记大规模操作中可预期但缺失的批量端点
   - 评估错误消息质量：错误是否可操作？是否告知集成方需要修复什么？
   - 识别缺失或不完整的分页、过滤和排序能力
   - 评估入职复杂度：新集成方需要多少步骤才能完成基本用例？

5. **文档完整性审查**：确保 API 文档达到专业标准。
   - 识别缺失的参数描述、未文档化的约束条件和缺失的示例值
   - 标记缺失的错误代码文档：每个端点在什么条件下会返回什么错误？
   - 评估 API 描述是否与实际实现一致
   - 识别缺失的认证文档和限流文档

6. **破坏性变更检测**：标记会破坏现有集成的提议变更。
   - 识别现有集成方可能依赖的字段、端点或枚举值的删除
   - 标记在没有适当版本控制的情况下属于破坏性的类型变更、字段重命名和语义变更
   - 为破坏性变更推荐版本控制策略

**可量化的成果**

- **集成支持工单**：在发布前进行 COCO 指导的 API 设计审查的团队，在上线后 90 天内的集成支持请求减少 44%
- **API 版本控制事件**：需要主版本号升级的破坏性 API 变更频率降低——团队报告每年的强制版本增量减少 38%
- **安全漏洞密度**：COCO 审查检测到的 API 设计阶段安全问题在首次审查时平均每端点 0.6 个；经 COCO 指导的重新设计后，降至 0.1 个
- **一致性评分**：通过 COCO 审查后上线的 API 在字段命名一致性上平均得分 8.2/10，而未审查的 API 为 5.1/10
- **审查吞吐量**：COCO 辅助的 API 设计审查耗时 45-90 分钟，而同等规模的手动审查需要 3-4 小时，在不增加审查负担的情况下进行更全面的审查

**受益对象**

- **后端和 API 开发者**：在发布前而非通过集成投诉才发现问题时，获得具体可操作的设计反馈
- **平台和开发者体验团队**：在数十个服务中强制执行 API 设计标准，而无需为每次变更都成立专门的 API 审查委员会
- **安全工程师**：在修复代价低廉（实现之前）时而非代价高昂（集成之后）时，捕获 API 设计阶段的安全漏洞
- **技术产品经理**：在做出客户承诺之前，了解 API 设计选择的可用性影响

---
## 实用提示词

**提示词 1：完整的 REST API 设计审查**
```
请审查以下 API 设计，检查一致性、正确性、可用性和安全问题。

API 规范（粘贴 OpenAPI/Swagger YAML 或 JSON，或描述端点）：
[粘贴 API 规范或端点描述]

上下文：
- API 类型：[REST / GraphQL / gRPC]
- 集成方：[仅内部服务 / 外部开发者 / 两者都有]
- 我们遵循的现有 API 规范：[描述任何现有规范，或粘贴您的 API 风格指南链接]
- 认证方式：[JWT / API Key / OAuth 2.0 等]

请审查并报告：
1. REST/HTTP 正确性问题：错误的动词、错误的状态码、非 RESTful 模式
2. 命名一致性问题：字段命名、端点命名、与既定规范的不一致
3. 安全设计问题：过度数据暴露、缺失限流、授权缺口
4. 可用性问题：需要太多往返的操作、缺失的批量端点、糟糕的错误消息
5. 文档完整性：缺失的描述、错误代码、示例
6. 总体设计评分（1-10）及理由
7. 发布前需要修复的前 3 个优先问题
```

**提示词 2：错误响应设计审查**
```
我想评估和标准化我们的 API 错误响应设计。

来自我们 API 的示例错误响应（粘贴来自不同端点的 5-10 个不同错误响应）：
[粘贴来自您 API 的实际错误响应 JSON 示例]

上下文：
- 此 API 中的端点数量：[大约数量]
- 我们的集成方使用的语言：[JavaScript、Python、Java 等]
- 现有的错误处理方式：[描述，或说"没有一致的方式"]
- 我们应该遵循的错误响应标准：[例如 RFC 9457 Problem Details、JSON:API errors 或自定义]

请：
1. 识别当前使用的所有不同错误响应模式
2. 评估每种模式：一致性、可操作性（是否告知集成方需要修复什么？）、可调试性（是否包含足够的上下文？）
3. 提议我们整个 API 应使用的统一错误响应模式
4. 显示迁移示例：每种现有模式应如何转换为统一格式？
5. 我们应该为最常见的错误类别定义哪些错误代码/类型？
6. 对于多字段请求，我们应如何传达验证错误？
```

**提示词 3：API 安全设计审查**
```
请审查此 API 设计的安全漏洞，重点关注 OWASP API Security Top 10。

要审查的 API 端点（粘贴规范或描述每个端点）：
[粘贴 API 规范或端点描述]

认证和授权设计：
[描述认证的工作方式以及授权决策的做出方式]

返回的数据模型（粘贴模式或描述）：
[粘贴响应模式或描述每个端点返回的数据]

请检查：
1. 对象级别授权被破坏（BOLA）：用户是否可以访问他们不拥有的对象？
2. 认证被破坏：认证设计中的弱点
3. 过度数据暴露：端点是否返回了超出所需的数据？
4. 缺少资源和限流：哪些端点需要限流以及需要什么限制？
5. 功能级别授权被破坏：仅管理员可用的功能是否得到充分保护？
6. 批量赋值：攻击者是否可以通过在请求体中包含不应该更新的字段来更新它们？
7. 安全配置错误：CORS 设置、暴露的内部端点等
8. 注入风险：在哪里应该指定额外的输入验证？

对每个发现的问题：描述漏洞、显示受影响的具体端点，并推荐设计修复。
```

**提示词 4：API 版本控制和破坏性变更审查**
```
我需要在发布前审查提议的 API 变更的破坏性影响。

当前 API 版本：[例如 v2]
提议的变更：
[描述或粘贴提议的变更——端点的添加、修改或删除]

当前 API 规范（已上线的版本）：
[粘贴当前规范的相关部分]

已知集成方：
- 内部服务：[列出使用此 API 的内部服务]
- 外部集成方：[外部集成方数量，如已知]
- SDK/客户端库：[是否有需要更新的 SDK]

请：
1. 对每个提议的变更分类：非破坏性 / 可能破坏性 / 破坏性——附说明
2. 对于每个破坏性变更：哪些具体的集成方代码会失败？
3. 所需的最低版本控制策略是什么：补丁、小版本还是大版本号升级？
4. 我们是否应该并行运行 v2 和 v3？持续多长时间？合理的弃用时间线是什么？
5. 在发布这些变更之前，我们需要向集成方传达什么？
6. 对于任何破坏性变更，是否存在达到相同目标的非破坏性设计替代方案？
```

**提示词 5：GraphQL 或 gRPC API 设计审查**
```
请审查此 [GraphQL 模式 / gRPC proto 定义] 的设计质量。

模式/proto 定义：
[粘贴 GraphQL 模式或 .proto 文件]

上下文：
- 用例：[此 API 的用途]
- 客户端：[谁将调用此 API——Web、移动端、内部服务]
- 现有规范：[我们遵循的任何风格指南或规范]
- 性能约束：[例如 必须支持慢速网络上的移动客户端]

对于 GraphQL，请审查：
1. 模式设计：类型、字段和关系是否建模良好？
2. 查询深度：是否存在无界查询深度风险需要限制深度？
3. N+1 风险：哪些解析器在没有 DataLoader 的情况下可预期会导致 N+1 问题？
4. Mutation 设计：mutation 是否遵循良好的命名规范并返回有用的载荷？
5. 分页：是否为所有列表类型实现了基于游标的分页？
6. 授权：字段级或类型级授权应在哪里被文档化？

对于 gRPC，请审查：
1. 服务和方法命名规范
2. 请求/响应消息设计：适当的字段类型、可选与必需等
3. 错误处理：状态码和错误详情的使用
4. 流式传输：流式 RPC 是否使用得当？
5. 未来变更的版本控制策略

总体设计质量和主要建议。
```

---
