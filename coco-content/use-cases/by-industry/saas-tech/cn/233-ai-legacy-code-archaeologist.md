# Use Case #233: AI Legacy Code Archaeologist

**Role**: 软件开发工程师 / 高级工程师 / 技术负责人 | **Industry**: SaaS、企业软件、金融科技、医疗IT | **Task**: 代码审查、遗留系统现代化、技术债分析、文档编写

---
## 详细介绍

**痛点：开发者每季度花费数周时间在没有人能完全解释的代码上**

遗留代码是软件工程中最昂贵、最不被承认的生产力消耗之一。加入一个有7年历史代码库的开发者，继承的是一个主要由已离职人员构建的系统——这些人使用的模式在2017年是合理的，但没有任何在世文档，业务逻辑埋藏在12层函数调用栈里，一个被误解的变量名就能触发生产故障的连锁反应。企业软件团队的研究发现，开发者在修改代码之前，需要花费42%的时间来理解现有代码。对于复杂的遗留系统，这个比例是倒置的：理解占总任务时间的60-70%，实际编码不到30%。

这一问题在三种高风险事件中尤为突出：新工程师入职、事故响应和遗留系统现代化项目。一家金融科技公司的新入职高级工程师平均需要14周才能在核心交易处理系统上达到完全生产力——不是因为他们缺乏技能，而是没有可靠的方法为一个拥有11年决策、变通方案和"临时"修复（后来变成永久保留）的40万行代码库建立心智模型。在生产事故期间，团队通常将事故总时长的40-60%花在诊断阶段，在陌生代码路径中追寻，而此时系统宕机，业务正在遭受损失。

遗留系统现代化项目是成本最高峰的地方。替换遗留单体系统在大多数组织是一个12-24个月的项目，而失败的首要原因之一——在38%的失败现代化项目中被提及——是"对现有系统行为的理解不完整"。团队在已经构建了不处理那些情况的替代系统之后，才发现嵌入代码中的未文档化业务规则。该规则由一位在2018年离职的开发者在2015年实现，唯一的文档是一行注释："处理来自财务的边缘案例。"结果这个边缘案例对季度末对账至关重要，新系统在发布时被卡住了。

**COCO如何解决**

COCO的AI遗留代码考古学家对代码库进行深度结构分析——追踪执行路径、识别隐性业务逻辑、呈现未文档化的依赖关系，并生成关于代码实际功能与预期功能的人类可读解释。

1. **执行路径追踪与调用图分析**：跨整个代码库映射任何代码单元的完整执行路径。
   - 跨文件和模块边界追踪函数调用，包括动态分发和依赖注入
   - 识别给定函数或方法的所有调用者——在修改前进行影响分析的关键
   - 为复杂子系统生成显示数据流和依赖链的可视化调用图
   - 标记循环依赖、死代码分支和不可达代码路径——这些表明了先前的缺陷或重构遗留物

2. **隐性业务逻辑提取**：识别在没有明确文档的情况下编码在代码中的业务规则。
   - 识别"魔法数字"（如0.035这类代表利率或税率阈值的硬编码值）并生成关于其业务含义的假设
   - 识别实现监管或业务政策规则的条件逻辑树，并用通俗语言解释决策逻辑
   - 与变量名、注释、提交消息和测试用例交叉引用，以三角定位代码实际在做什么
   - 标记与函数名称或周围注释声称不一致的业务逻辑

3. **依赖与集成考古**：映射完整的依赖关系，包括可能已不再有效的外部集成。
   - 识别所有外部API调用、数据库查询、文件I/O和服务间通信
   - 检测可能导致无声失败或安全漏洞的已废弃API端点或库
   - 映射嵌入代码中的数据库模式假设——假设当前模式文档中未反映的列存在或数据类型的查询
   - 识别环境特定行为：基于环境变量在开发与生产中运行不同的代码

4. **自动遗留文档生成**：从代码分析中产出结构化文档，填补不存在的空白。
   - 生成函数级文档，解释从代码行为推断出的输入、输出、副作用和前置条件
   - 产出模块级摘要，解释每个代码组件的业务目的
   - 创建显示数据在系统中流转时如何转换的数据流图
   - 生成"已知未知"报告：代码库中无法仅从代码自信确定行为的区域，需要人工核实

5. **现代化风险评估**：对于遗留系统替换项目，在复杂性脱轨时间表之前识别隐性风险。
   - 识别在任何替换中必须保留的系统组件间的所有隐性契约
   - 标记实现边缘案例或异常处理的代码——全新重写很可能遗漏这些
   - 根据耦合指标、圈复杂度和依赖密度估算每个模块的现代化复杂度
   - 产出风险排序的现代化顺序建议：先替换哪些模块，最后保留哪些

**可量化的结果**

- **新开发者入职时间**：复杂遗留系统达到完全生产力的时间从10-14周缩短至5-7周——每位新员工节省5-7周的半产出高级开发者时间
- **事故诊断时间**：在陌生遗留代码中确定根本原因减少55%——从每次事故平均3.2小时降至1.4小时
- **修改前影响分析**：识别提议变更影响的所有代码的时间从4-6小时（手动grep和追踪）缩短至25-40分钟
- **隐藏业务逻辑发现**：现代化遗留系统的团队报告，COCO每5万行代码平均识别出23条否则会被遗漏的未文档化业务规则
- **现代化范围准确度**：使用COCO进行前期遗留分析的项目报告，在现代化项目期间的范围变更比依赖手动分析的团队少31%

**受益角色**

- **软件开发工程师**：减少迷惑时间，增加产出时间——在修改代码前理解代码功能，降低引入回归的风险
- **高级工程师和技术负责人**：将遗留考古工作委托给COCO，而不是成为团队对老系统的唯一"人类百科全书"
- **工程经理**：为遗留现代化项目产出准确的时间和风险估算，而非一再低估40-60%的猜测
- **SRE和平台团队**：当受影响代码在当前团队成员加入前构建的系统中时，更快诊断生产事故

---

## 实用提示词

**提示词1：陌生函数深度分析**
```
我在修改一个遗留代码库中的函数之前，需要先完全理解它。帮我建立一个完整的心智模型。

函数：[在此粘贴完整函数代码]

我能提供的背景：
- 语言和框架：[例：Java 8, Spring Boot 2.1]
- 文件位置：[例：src/main/java/com/company/billing/InvoiceProcessor.java]
- 相邻代码（我知道的调用者）：[粘贴任何调用代码或描述背景]
- 系统大概做什么：[例：这是我们的账单系统，处理每月发票]
- 我想要做的变更：[描述你需要做的修改]

请：
1. 用通俗英语解释这个函数实际上做什么——它真正的业务目的是什么？
2. 识别逻辑中任何"魔法数字"、硬编码字符串或隐性假设
3. 列出所有前置条件：输入需要满足什么条件才能使此函数正确运行？
4. 除返回值之外的副作用是什么？（状态变更、写操作、外部调用）
5. 这个函数处理了哪些边缘案例？有哪些它可能应该处理但没有的？
6. 我提议的变更最可能以哪些方式破坏现有行为？
7. 在做我的变更之前，我应该编写或验证哪些测试？
```

**提示词2：遗留模块业务逻辑提取**
```
在我们替换一个遗留模块之前，我需要提取并文档化其中嵌入的所有业务规则。

模块代码：[粘贴相关文件或关键文件——如果太大，粘贴最复杂的200-400行]
模块背景：
- 它是什么的一部分：[例：我们的订单管理系统，处理订单状态转换]
- 估计的原始目的（基于我们所知）：[你认为它做什么]
- 技术：[语言、框架、大致年龄（如已知）]
- 已知业务背景：[关于它支持的业务流程的任何领域知识]

请：
1. 列出你在这段代码中能识别的每一条业务规则——尽量详尽。格式：规则：[通俗描述] — 来源：[代码中的位置]
2. 标记任何似乎与监管或合规相关的规则（这些遗漏风险最高）
3. 识别任何相互矛盾或存在明显冗余的规则
4. 标记任何"可疑"规则——看起来是为处理特定事故或已不再相关（或非常相关但未文档化）的例外情况而添加的逻辑
5. 列出"已知未知"：这段代码中你无法单从代码解释的决策——需要前团队成员或业务干系人澄清的内容
6. 产出这个模块功能的通俗英语规格说明，适合交给构建替换系统的工程师
```

**提示词3：修改前影响分析**
```
在我修改遗留代码之前，我需要了解完整的影响范围。

我计划的变更：
- 我在修改：[描述你在更改什么——函数名、类、数据库列、API契约等]
- 变更内容：[描述具体变更]
- 原因：[为什么要做这个变更]

代码背景：
[粘贴被修改的代码]

已知依赖（我已知道调用此代码的内容）：
[列出你已知道的任何调用者或依赖者]

代码库背景：
- 语言：[语言]
- 系统：[描述更广泛的系统——微服务、单体等]
- 部署背景：[这段代码如何部署——有测试环境吗？有功能开关吗？]

请：
1. 基于代码模式和描述的变更，我应该搜索哪些类别的调用者或依赖者？
2. 我应该运行哪些具体的grep模式或代码搜索查询来找到所有受影响的代码？
3. 可能需要哪些数据库查询或数据迁移？
4. 哪些测试用例最可能覆盖我正在改变的行为——哪些可能在我变更后错误地通过？
5. 这个变更潜在影响哪些配置、环境变量或外部系统契约？
6. 基于这个分析，你对这个变更的风险评估是什么：低/中/高——关键风险是什么？
7. 这个变更的安全发布序列应该是什么样的？
```

**提示词4：事故根因考古**
```
我们正在调查一个生产事故，失败的代码在一个我不完全了解的遗留系统中。

事故描述：
- 什么在失败：[描述症状——错误信息、数据错误、服务宕机等]
- 何时开始：[时间戳或相对时间]
- 错误输出：[粘贴错误信息、堆栈跟踪或日志摘录]
- 最近的变更：[事故前48小时内的任何部署、配置变更或数据变更]

相关遗留代码：
[粘贴堆栈跟踪或错误信息指向的代码片段]

系统背景：
- 这个系统做什么：[简要描述]
- 已知集成：[这段代码与之交互的外部系统]
- 它处理的数据：[什么数据流经这个代码路径]

请：
1. 从入口点到失败点追踪执行路径——代码在每一步应该做什么？
2. 在失败点：什么条件或状态会导致这个具体错误？
3. 鉴于列出的最近变更，哪些（如果有的话）可能合理地导致了这次失败？为什么？
4. 我还应该调查哪些其他潜在原因？按可能性排序。
5. 哪些诊断查询或日志搜索能够确认或排除每个假设？
6. 一旦我们确定根本原因，最小可行修复与正确修复是什么？仅应用最小可行修复有什么风险？
```

**提示词5：现代化准备度评估**
```
我们计划用现代实现替换一个遗留模块。帮我了解我们将面临的挑战。

要替换的遗留模块：
[粘贴代码或描述该模块——如果较大，粘贴主要入口点和最复杂的部分]

替换背景：
- 我们为什么要替换它：[性能、可维护性、新需求等]
- 目标技术：[我们用什么替换它]
- 我们希望的时间表：[月数]
- 参与的团队规模：[工程师人数]

请产出现代化评估：
1. 复杂度评分（1-10分）附理由：替换这个有多难？
2. 隐性依赖：这段代码依赖于什么，这些从阅读代码来看并不明显？
3. 隐性契约：系统其余部分依赖于什么行为，全新替换必须精确保留？
4. 高风险业务规则：嵌入这段代码中的哪些规则在全新重写中最可能被遗漏？
5. 建议的现代化方法：扼杀无花果模式、大爆炸还是逐模块？为什么？
6. 建议的阶段划分：我们应该先处理什么，最后留什么？
7. 现实的时间表估算：鉴于复杂度评估，你建议什么时间表，以及对该时间表的主要风险是什么？
```

---
